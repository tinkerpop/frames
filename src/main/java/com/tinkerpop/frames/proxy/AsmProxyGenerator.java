package com.tinkerpop.frames.proxy;

import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;

import com.tinkerpop.blueprints.Element;
import com.tinkerpop.frames.FramedElement;
import com.tinkerpop.frames.annotations.AnnotationHandler;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Type;

import static org.objectweb.asm.Opcodes.*;
import static org.objectweb.asm.Type.*;

/**
 * Proxy generator that returns directly created bytecode classes from ASM, this is the fastest
 * proxy generator but has implications on security for secure contexts
 *
 * @author Greg Bowyer
 */
public class AsmProxyGenerator implements ProxyGenerator {

    private static final Map<Class, Class> AUTOBOXING_HANDLERS = new HashMap<Class, Class>() {{
        put(int.class, Integer.class);
        put(float.class, Float.class);
        put(double.class, Double.class);
        put(short.class, Short.class);
        put(long.class, Long.class);
        put(byte.class, Byte.class);
        put(char.class, Character.class);
    }};

    private static final Map<String, String> magicFields = new HashMap<String, String>() {{
        put("methods", "[Ljava/lang/reflect/Method;");
        put("delegates", "[Lcom/tinkerpop/frames/annotations/AnnotationHandler;");
        put("element", "Lcom/tinkerpop/frames/FramedElement;");
        put("isVertex", "Z");
        put("annotations", "[Ljava/lang/annotation/Annotation;");
    }};

    private static final int[] INT_PUSH_OPCODES = {
        ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5
    };

    public static final String DELEGATE_SIG = getMethodDescriptor(getType(Object.class), new Type[]{
        getType(int.class), getType(FramedElement.class), getType(Object[].class)
    });

    private Map<Class, Proxy> classCache = new WeakHashMap<Class, Proxy>();

    class Proxy {
        public final Method[] methods;
        public final Annotation[] annotations;
        public final AnnotationHandler[] handlers;
        public final Class proxy;
        public final Constructor constructor;

        Proxy(Method[] methods, Annotation[] annotations, AnnotationHandler[] handlers, Class proxy) {
            this.methods = methods;
            this.annotations = annotations;
            this.handlers = handlers;
            this.proxy = proxy;
            this.constructor = proxy.getConstructors()[0];
        }
    }

    @Override
    public <F> F generate(Class<F> clazz, FramedElement framedElement,
                          Map<Class<? extends Annotation>, AnnotationHandler<? extends Annotation>> annotationHandlers) {
        synchronized (classCache) {
            if (!classCache.containsKey(clazz)) {
                classCache.put(clazz, generateProxy(clazz, annotationHandlers));
            }
        }

        try {
            Proxy proxy = classCache.get(clazz);

            // This might be a bottleneck, if it is we can make a class that stubs this through another
            // autogenerated bit that can act as a factory and be bound to an interface
            // that will leave reflection behind for an InvokeVirtual call which is Jit faster
            // ... we could also detect java7 (or specialise this class) and use the MethodHandles / InvokeDynamic
            // support
            return (F) proxy.constructor.newInstance(proxy.methods, proxy.handlers, framedElement, proxy.annotations);
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
       } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }

    private <F> Proxy generateProxy(Class<F> clazz, Map<Class<? extends Annotation>,
                                    AnnotationHandler<? extends Annotation>> annotationHandlers) {
        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);

        final String className = clazz.getSimpleName() + "$$TPGENERATED$$1";
        final String implName = clazz.getSimpleName() + "$$TPGENERATED$$1";

        writer.visit(V1_5,
            ACC_PUBLIC + ACC_SUPER,
            implName,
            null,
            "java/lang/Object",
            new String[] { getInternalName(clazz) });

        writer.visitSource(null, null);

        writeMagicFields(writer);
        writeConstructor(writer, implName);
        writeDelegateMethod(writer, implName);
        List<Method> foundMethods = new ArrayList<Method>();
        List<Annotation> foundAnnotations = new ArrayList<Annotation>();
        List<AnnotationHandler> foundHandlers = new ArrayList<AnnotationHandler>();
        writeMethods(writer, clazz, implName, foundMethods, foundAnnotations, foundHandlers, annotationHandlers);

        writer.visitEnd();

        final byte[] b = writer.toByteArray();
        Class toReturn = new ClassLoader(clazz.getClassLoader()) {
            Class cc = defineClass(className, b, 0, b.length);
        }.cc;

        Method[] returnMethods = new Method[foundMethods.size()];
        foundMethods.toArray(returnMethods);
        Annotation[] returnAnnotations = new Annotation[foundAnnotations.size()];
        foundAnnotations.toArray(returnAnnotations);

        AnnotationHandler[] returnHandlers = new AnnotationHandler[foundHandlers.size()];
        foundHandlers.toArray(returnHandlers);

        return new Proxy(returnMethods, returnAnnotations, returnHandlers, toReturn);
    }
    
    private void writeMagicFields(ClassWriter writer) {
        final int access = ACC_PRIVATE + ACC_FINAL;
        for (Map.Entry<String, String> field : magicFields.entrySet()) {
            writer.visitField(access, field.getKey(), field.getValue(), null, null).visitEnd();
        }
    }

    private void writeConstructor(ClassWriter writer, String implName) {
        MethodVisitor mv = writer.visitMethod(ACC_PUBLIC, "<init>",
            "([Ljava/lang/reflect/Method;[Lcom/tinkerpop/frames/annotations/AnnotationHandler;" +
                "Lcom/tinkerpop/frames/FramedElement;" +
                "[Ljava/lang/annotation/Annotation;)V",
            null, null);
        mv.visitCode();
        mv.visitVarInsn(ALOAD, 0);
        mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V");
        mv.visitVarInsn(ALOAD, 0);
        mv.visitVarInsn(ALOAD, 2);
        mv.visitFieldInsn(PUTFIELD, implName, "delegates", getDescriptor(AnnotationHandler[].class));
        mv.visitVarInsn(ALOAD, 0);
        mv.visitVarInsn(ALOAD, 1);
        mv.visitFieldInsn(PUTFIELD, implName, "methods", getDescriptor(Method[].class));
        //"[Ljava/lang/reflect/Method;");
        //"[Lcom/tinkerpop/frames/annotations/AnnotationHandler;");
        mv.visitVarInsn(ALOAD, 0);
        mv.visitVarInsn(ALOAD, 3);
        mv.visitFieldInsn(PUTFIELD, implName, "element", getDescriptor(FramedElement.class));
        //"Lcom/tinkerpop/frames/FramedElement;");
        mv.visitVarInsn(ALOAD, 0);
        mv.visitVarInsn(ALOAD, 4);
        mv.visitFieldInsn(PUTFIELD, implName, "annotations", getDescriptor(Annotation[].class));
        //"[Ljava/lang/annotation/Annotation;");
        mv.visitVarInsn(ALOAD, 0);
        mv.visitVarInsn(ALOAD, 3);
        mv.visitMethodInsn(INVOKEVIRTUAL, getInternalName(FramedElement.class),
            "getElement",
            getMethodDescriptor(getType(Element.class), new Type[]{}));
        mv.visitTypeInsn(INSTANCEOF, "com/tinkerpop/blueprints/Vertex");
        mv.visitFieldInsn(PUTFIELD, implName, "isVertex", "Z");
        mv.visitInsn(RETURN);
        mv.visitMaxs(2, 5);
        mv.visitEnd();
    }

    private void writeDelegateMethod(ClassWriter writer, String implName) {
        MethodVisitor mv = writer.visitMethod(ACC_PRIVATE + ACC_FINAL,
            "__tp_generated_delegate", DELEGATE_SIG, null, null);
        mv.visitCode();
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, implName, "isVertex", "Z");
        Label l0 = new Label();
        mv.visitJumpInsn(IFEQ, l0);
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, implName, "delegates", "[Lcom/tinkerpop/frames/annotations/AnnotationHandler;");
        mv.visitVarInsn(ILOAD, 1);
        mv.visitInsn(AALOAD);
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, implName, "annotations", "[Ljava/lang/annotation/Annotation;");
        mv.visitVarInsn(ILOAD, 1);
        mv.visitInsn(AALOAD);
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, implName, "methods", "[Ljava/lang/reflect/Method;");
        mv.visitVarInsn(ILOAD, 1);
        mv.visitInsn(AALOAD);
        mv.visitVarInsn(ALOAD, 3);
        mv.visitVarInsn(ALOAD, 2);
        mv.visitMethodInsn(INVOKEVIRTUAL, "com/tinkerpop/frames/FramedElement", "getGraph", "()Lcom/tinkerpop/frames/FramedGraph;");
        mv.visitVarInsn(ALOAD, 2);
        mv.visitMethodInsn(INVOKEVIRTUAL, "com/tinkerpop/frames/FramedElement", "getElement", "()Lcom/tinkerpop/blueprints/Element;");
        mv.visitTypeInsn(CHECKCAST, "com/tinkerpop/blueprints/Vertex");
        mv.visitMethodInsn(INVOKEINTERFACE, "com/tinkerpop/frames/annotations/AnnotationHandler",
            "processVertex",
            "(Ljava/lang/annotation/Annotation;Ljava/lang/reflect/Method;" +
                "[Ljava/lang/Object;Lcom/tinkerpop/frames/FramedGraph;" +
                "Lcom/tinkerpop/blueprints/Vertex;)Ljava/lang/Object;");
        Label l1 = new Label();
        mv.visitJumpInsn(GOTO, l1);
        mv.visitLabel(l0);
        mv.visitFrame(F_SAME, 0, null, 0, null);
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, implName, "delegates", "[Lcom/tinkerpop/frames/annotations/AnnotationHandler;");
        mv.visitVarInsn(ILOAD, 1);
        mv.visitInsn(AALOAD);
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, implName, "annotations", "[Ljava/lang/annotation/Annotation;");
        mv.visitVarInsn(ILOAD, 1);
        mv.visitInsn(AALOAD);
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, implName, "methods", "[Ljava/lang/reflect/Method;");
        mv.visitVarInsn(ILOAD, 1);
        mv.visitInsn(AALOAD);
        mv.visitVarInsn(ALOAD, 3);
        mv.visitVarInsn(ALOAD, 2);
        mv.visitMethodInsn(INVOKEVIRTUAL, "com/tinkerpop/frames/FramedElement", "getGraph", "()Lcom/tinkerpop/frames/FramedGraph;");
        mv.visitVarInsn(ALOAD, 2);
        mv.visitMethodInsn(INVOKEVIRTUAL, "com/tinkerpop/frames/FramedElement", "getElement", "()Lcom/tinkerpop/blueprints/Element;");
        mv.visitTypeInsn(CHECKCAST, "com/tinkerpop/blueprints/Edge");
        mv.visitVarInsn(ALOAD, 2);
        mv.visitMethodInsn(INVOKEVIRTUAL, "com/tinkerpop/frames/FramedElement", "getDirection",
            "()Lcom/tinkerpop/blueprints/Direction;");
        mv.visitMethodInsn(INVOKEINTERFACE, "com/tinkerpop/frames/annotations/AnnotationHandler",
            "processEdge",
            "(Ljava/lang/annotation/Annotation;Ljava/lang/reflect/Method;" +
                "[Ljava/lang/Object;Lcom/tinkerpop/frames/FramedGraph;" +
                "Lcom/tinkerpop/blueprints/Edge;Lcom/tinkerpop/blueprints/Direction;)" +
                "Ljava/lang/Object;");
        mv.visitLabel(l1);
        mv.visitFrame(F_SAME1, 0, null, 1, new Object[]{"java/lang/Object"});
        mv.visitInsn(ARETURN);
        mv.visitMaxs(7, 4);
        mv.visitEnd();
    }

    private <F> void writeMethods(ClassWriter writer, Class<F> clazz, String implName,
                                  List<Method> foundMethods, List<Annotation> foundHandles, List<AnnotationHandler> foundHandlers,
                                  Map<Class<? extends Annotation>, AnnotationHandler<? extends Annotation>> handlers) {
        Method[] methods = clazz.getMethods();

        for(int i=0; i<methods.length; i++) {
            Method method = methods[i];
            final Annotation[] annotations = method.getAnnotations();
            for (final Annotation annotation : annotations) {
                if (handlers.containsKey(annotation.annotationType())) {
                    foundMethods.add(method);
                    foundHandles.add(annotation);
                    foundHandlers.add(handlers.get(annotation.annotationType()));

                    MethodVisitor mv = writer.visitMethod(ACC_PUBLIC, method.getName(), getMethodDescriptor(method), null, null);
                    mv.visitCode();
                    mv.visitVarInsn(ALOAD, 0);
                    writeIntPush(mv, i);
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, implName, "element", "Lcom/tinkerpop/frames/FramedElement;");
                    int localArgs = writeDelegateArrayArgs(mv, method);
                    mv.visitMethodInsn(INVOKESPECIAL, implName, "__tp_generated_delegate", DELEGATE_SIG);
                        
                    //"(ILcom/tinkerpop/frames/FramedElement;[Ljava/lang/Object;)Ljava/lang/Object;");
                    if (method.getReturnType() == null || method.getReturnType() == void.class) {
                        mv.visitInsn(POP);
                        mv.visitInsn(RETURN);
                    } else {
                        mv.visitTypeInsn(CHECKCAST, getInternalName(method.getReturnType()));
                        mv.visitInsn(ARETURN);
                    }
                    // LocalArgs + (self pointer + element + array index)
                    mv.visitMaxs(localArgs + 3, localArgs);
                    mv.visitEnd();
                }
            }
        }
    }

    private static int writeDelegateArrayArgs(MethodVisitor mv, Method method) {
        int arity = 1;
        Class[] argTypes = method.getParameterTypes();
        if (argTypes.length == 0) {
            mv.visitInsn(ACONST_NULL);
        } else {
            writeIntPush(mv, argTypes.length);
            mv.visitTypeInsn(ANEWARRAY, "java/lang/Object");
            mv.visitInsn(DUP);
            for (int i=0; i<argTypes.length; i++) {
                writeIntPush(mv, i);
                arity += writeVarStackLoad(mv, argTypes[i], arity);
                //mv.visitVarInsn(ALOAD, i + 1);
                writePotentialAutoBox(mv, argTypes[i]);
                mv.visitInsn(AASTORE);
                if (i + 1 > argTypes.length) {
                    mv.visitInsn(DUP);
                }
            }
        }
        return arity;
    }

    private static int writeVarStackLoad(MethodVisitor mv, Class argType, int arity) {
        // Deal with the double words first
        if (argType == long.class) {
            mv.visitVarInsn(LLOAD, arity);
            // Double word here 
            return arity + 1;
        }

        if (argType == double.class) {
            mv.visitVarInsn(DLOAD, arity);
            return arity + 1;
        }

        // Floats get their own special opcode, but dont mess with arity
        if (argType == float.class) {
            mv.visitVarInsn(FLOAD, arity);
        } else if (argType.isPrimitive()) {
            mv.visitVarInsn(ILOAD, arity);
        } else {
            mv.visitVarInsn(ALOAD, arity);
        }

        return arity;
    }

    private static void writePotentialAutoBox(MethodVisitor mv, Class argType) {
        if (argType.isPrimitive()) {
            Class autoboxHandler = AUTOBOXING_HANDLERS.get(argType);
            String methodDescriptor = getMethodDescriptor(getType(autoboxHandler), new Type[]{getType(argType)});
            mv.visitMethodInsn(INVOKESTATIC, getInternalName(autoboxHandler), "valueOf", methodDescriptor);
        }
    }

    private static void writeIntPush(MethodVisitor mv, int value) {
        if (value < 6) {
            mv.visitInsn(INT_PUSH_OPCODES[value]);
        } else if (value >= -128 && value <= 127) {
            mv.visitIntInsn(BIPUSH, value);
        //SIPUSH is good for value >= -32768 && value <=32767
        } else if (value >= -255 && value <=254) {
            mv.visitIntInsn(SIPUSH, value);
        } else {
            throw new IllegalArgumentException("Too many arguments for a method");
        }
    }

}

